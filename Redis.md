### 什么是redis？
   redis是由C语言编写的基于缓存操作的高性能kv数据库，提供五种基本的数据类型，如：string，list，hash，set，zset分别应对不同的场景使用，除此之外还有HyperLogLog，bitmap，BloomFitter，GEO，pub/sub，Pipeline等高级的数据结构应对特定的使用场景。同时Redis也支持将数据持久化得到磁盘，保证了数据的安全性。

### Redis常用的几种数据类型是怎么实现的，各自有什么应用场景？
   string，实现方式是使用简单动态字符串，为什么不直接使用C的字符串呢？那是因为C的字符串的每个字符串后面都会加上一个"\0"的结束符，在进行字符串操作的时候如果操作不当可能会造成内存溢出，而且C的字符串如果要获取长度的话需要进行遍历，这种对于要求性能极高的Redis来说是不能容忍的，而简单动态字符串会通过变量保存字符串长度，获取的时间复杂度只有O(1)；还有就是C的字符串只能保存文本数据，就是需要通过某种编码的，如果"\0"这种C就无法保存；在分配内存方面，简单动态字符串会预先分配好成倍的空间，减少内存分配的次数，缩容时也并没有直接回收掉，C的话涉及字符串长度的改变就会重新分配。它的应用场景就很广泛了，比如保存登录的用户信息，计数器，验证码等。
   list，实现方式主要是通过链表，这就意味着list的插入和删除的性能很高，时间复杂度在O(1)，同时也可以用它来模拟入栈出栈，入队出队这种操作。应用场景的话如，保存某一类活动的商品信息列表。
   hash，实现方式类似Java的HashMap，也会通过数组加链表的方式解决hash冲突，就是如果有多个数据hash到同一个桶下面的话，后面的数据就会以链表的方式保存；当hash中的元素个数等于第一维数组的长度时就会进行扩容，扩容长度是原来的两倍，当元素稀疏时，元素个数低于数组长度的10%就会缩容。
   set，实现方式类似Java的HashSet，内部的键值是唯一且无序的，字典中所有value的值都是一个null。
   zset，实现方式就是HashMap和SortedSet的结合，一方面通过set来保证键值唯一，其次可以给value一个分数，通过分数来进行排序。同时，zset还实现了跳表，因此查找数据的性能也很高。应用场景有，排行榜。

### 什么是渐进式rehash？
   hash数据在进行扩容时，是一个循序渐进的过程，创建一个新的hash对象，并通过定时任务之类的逐渐将数据同步到新hash中，在对旧hash增删改中也会发送命令同步新hash中的数据，数据同步完成之后，就会彻底换掉旧hash对象，用新的hash数据。

### Redis单线程
   虽然一直都在说redis是单线程，但它其实不完全是单线程，它只有在处理连接事件和操作数据的时候是单线程，其他如持久化，主从复制，集群等是会开启子进程后台处理的。同时，redis也使用了多路IO复用来提供单线程操作的并发性及性能提升，多路IO就是通过一个管道来收集多个进程IO请求，然后用一个线程来监听管道取出IO请求，并分发到对应的事件处理器上，一定程度上提升了CPU的利用率。

### Redis持久化
   redis的持久化主要是通过两种文件，分别是RDB和AOF。RDB方式就是redis的全量备份了，一般会定时，大约5分钟一次（可设置）执行RDB备份，执行方式大致就是fork一个子进程在后台备份当前的数据，将当前的数据内容记录到RDB文件中，主进程继续接受处理请求操作数据，并通过COW（写时拷贝）机制，备份时如果修改数据结构，会copy一份当前数据的拷贝，主进程修改拷贝的内容，子进程依然备份修改之前的内容。使用RDB做数据恢复性能较高，可以快速恢复，除了配置参数让他定时执行快照，还可以通过bgsave命令手动执行备份。RDB非常适合做冷备，可以非常快速的恢复之前的某一个节点时间的数据。
   AOF则是会将每条操作数据的命令追加写入AOF文件中，在数据恢复时就重放AOF中记录的操作命令。AOF也不是在每条命令写入时就立刻持久化到磁盘，它会先将命令保存到一个缓冲池中，每隔一秒定时刷到磁盘，也可以使用fsyn命令强制刷盘，不过比较损耗redis资源。相对于RDB，AOF方式的持久化更加的安全，可以持久化更加完整的数据，如果AOF每秒执行，则也只丢失那一秒的数据，但是在恢复过程中，性能比起RDB就逊色不少，同样数据内容下，AOF会比RDB文件大不少。AOF适合做灾难性删除事件的备份，比如某个程序员不小心执行了清空缓存的命令，但此时如果快速拷贝一份AOF文件并删除掉那个清除命令然后重放，就可以完整的恢复数据。
   一般对缓存的部分数据丢失并没有太大影响情况下的话可以用RDB，否则还是使用AOF。不过正常情况下是可以混合使用的，比如说先使用RDB快照保存当前时间节点下的数据，在RDB持久化空档期使用AOF记录操作命令。数据恢复时先读取RDB的快照数据，在找到快照最后的时间节点执行AOF恢复。

### Redis的zset和跳表问题
   首先跳表是应用于一个有序的链表结构，传统的链表结构从头指针开始记录下一个节点的地址，如果要查找某个节点只能从头指针开始遍历查找，最坏的情况时间复杂度达O(n)。而跳表的话节点不在只有一个指向的节点，比如（1->2->3->4->5），节点不仅指向2，还可以多指向3，节点3不仅指向4，还可以多指向5，这样套多了一级链表结构，如果要找节点4时，先从节点1出发找到节点3，再从节点3出发找到节点4，非常大的提升的查找效率，而且跳表不止套两层，可以套多层这样链表结构。
   但是这样又有一个问题，就是每次增删的时候都需要重新调整跳表结构，如果嵌套了多层结构的情况下，这样的调整无疑是比较损耗资源的。有一种解决方法就是使用随机的方式，如嵌套的第二层是1->3->4,第三层是1->4->5，节点指向并没有规律，这样增删时也不需要调整了。

### Redis为什么这么快？
   众所周知，redis是基于内存操作的，这是它性能之高的一大特点，除此之外，它的数据类型实现了例如：简单动态字符串，压缩列表，跳表等优秀的数据结构，支撑着redis在增删改查数据时高效性，还有提供了多路IO服用这一策略，让多个进程的不同请求事件得到并行处理，还有一个特点就是单线程的操作，避免了上下文切换和多个进程竞争资源的问题。

### Redis哨兵
   集群是保证redis高可用的一种有效手段，通过搭建多套redis服务，各自分担一定的读写请求压力，即使其中一台宕机其他redis服务仍可提供服务。为了更有效的管理redis集群模式，redis使用了一种叫哨兵的服务机制，主要原理就是：声明多个哨兵（一般是3个以上）分别监听服务器的健康状态，会定时的向服务发送心跳检测，如果没有及时回应，不会立刻做故障转移，只有等半数以上的哨兵发现之后，选举投出一个新的master替换掉故障的master，并发通知其他从机更换了master主机。

### Redis主从同步
   redis主从模式下，数据的增删改操作会作用到master主机上，而从机提供查询读取功能。在对master主机写操作后，需要同步数据到从机，否则会出现数据不一致问题。master主机通常是fork一个子进程，进行RDB快照数据备份，再发送给从机，如果此时还有写的命令则会缓存到内存中，从机接受到后先持久化到磁盘，然后再加载进内存进行数据同步，之后master会把缓存的数据新命令发送给从机。

### Redis删除过期key策略
   删除过期key的策略有定期删除和惰性删除。定期删除就是定时抽取一部分设置了过期时间的key出来，检测是否过期，如果过期则删除，但是这种方式容易缺漏明明过期的key缺没有被删掉的情况，于是又有了惰性删除。惰性删除就是等查询这个key的时候，redis检测查询的key是否已经过期，如果过期了则不返回数据并将它删除。可是如果定期没有抽取到，也没有查询的话，那key不是一直处于过期未删状态下？如果这两种情况也不能清除掉的话还有内存淘汰策略。
   redis还提供了一系列内存淘汰策略来回收掉我们过期的key。如：LRU淘汰，从一堆key中拿出最近最近未使用的key并将其淘汰掉，可以指定从设置了过期时间的key堆；回收设置了过期key中，优先回收存活时间更小的key；随机删除一堆key中的一部分，同样可以指定设置了过期时间的；最后当然也可以不使用这些策略，也就是不做淘汰策略。

### Redis分布式锁
   redis也是可以提供分布式锁的，实现方式就是使用setnx命令，该命令在添加key时会判断key是否存在，存在则不处理，否则就插入。为了保证key不会一直被锁下去都会设置过期时间，但是如果使用expire方式设置的话操作就不满足原子性了，并发时还是可能导致key一直锁着。不过好在redis 已经提供了对setnx命令的优化，可以直接在后面加上过期时间，用一条命令执行，保证了原子性操作。
   但是当发生主从切换的话，就会有问题了。比如：客户端A在master请求加锁成功了，但是此时master宕机了，还没把加锁成功的消息同步到其他从机，但客户端A以为自己已经加锁成功了，于是请求新选举的master发现失败了。那要怎么解决这种问题呢？redis作者提出了一个方案就是用RedLock。RedLock实现就是客户端向集群中的redis服务分别申请锁，如果有超过半数的服务申请成功了，则表示加锁成功，否则将失败，并释放掉所加的锁。
   
### Redis双写一致性问题？
   我们一般就是将查询结果缓存到redis，查询的数据来源一般就是使用MySQL之类的数据库，但如果更新了数据库的数据，要怎么保证数据的一致性。
   比较常用的做法就是，先删除redis中的缓存，在更新数据库的数据，等下次查询的时候直接查询数据再放入缓存中。但是这样会有什么问题呢？就是说如果在删除缓存之后，还没更新完数据库，此时又另一个请求过来查询了数据库，又将数据放到缓存了，之后数据库更新完成了，但此时redis中的还是旧数据，就导致不一致了。解决方案就是：延时双删，就是在更新之前先清除缓存，此时如果有请求又将旧数据放入到缓存了，更新完成后，先进行等待，等待的时间可以略大于一次查询并放入缓存的时间，时间到了之后再次将缓存清除，这时之前缓存的旧数据也会被清除了。
   还有就是先更新数据库，再清除缓存的场景，如果此时更新完数据库但是还没来得及清除缓存，有新请求过来就直接查询到旧数据了。此时解决方法是，引入队列，将写和读串行化，不过这样明显并发量就小很多，如果不是对一致性要求特别严格的没必要用这种方式。
   不过为什么是直接删除缓存而不是更新缓存？如果我们保存的数据比较复杂，比如是联合多个表经过处理计算后的结果，这种情况下要更新的代价相比就更高了，而且如果是高写的场景下，但是访问却不多，在这期间修改了100次数据库，但是一直没有读，这样缓存的数据占用空间相对浪费。

### Redis的BloomFitter
   布隆过滤器是由多种hash函数和位数组组成的一种特殊数据结构，用于判断一个数据是否存在，具有相当高的性能，同时能应对海量数据，空间复杂度和时间复杂度都很低。缺点就是有一定的误判率。
   实现原理就是首先有一定长度的位数组，数组初始全部为0，同时还具备多个hash函数，如果有数据要存储的话，会经过多个hash函数，每个hash函数会给出一个位数组的索引位，然后分别将这几个索引位的数据置为1，表示存储完成。如果要判断数据的话，同样将数据经过多个hash处理，得出多个hash给出的索引位，判断是否全为1，如果不是则不存在，如果是就存在。不过有个问题就是，如果其他数据也将那个索引位置为1了，就可能出现这个数据本来不存在，但是却被认为存在，也就是出现误判了。所以需要在对数据有一点点的误判容错的情况下，使用布隆过滤器是个不错的选择。
   
### HyperLogLog
   HyperLogLog是用于基数统计的，就是统计某一个数据的出现次数，像统计一个用户对当前页面的访问量这种场景就十分有用了。