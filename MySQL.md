### mysql架构
   主要分为四层：连接层，服务层，引擎层，存储层。
   - 连接层主要是接收客户端进行连接，包括认证，鉴权及一系列安全的方案。
   - 服务层就是mysql提供核心服务的地方，包括sql的语义分析，词法分析，查询优化等，同时mysql 的缓存也在这一层。
   - 引擎层是真正提供数据存取的地方，不同的引擎具备不用等功能特性，服务器可以调用API与存储引擎通信。
   - 存储层，负责将数据存储在该文件系统等设备上，与引擎层交互。

### MyISAM与InnoDB的区别
   - MyISAM不支持事务，InnoDB支持事务。
   - MyISAM锁的粒度最小到表锁，InnoDB锁粒度最小到行锁。
   - MyISAM会记录表的数据行数，InnoDB不会记录。
   - MyISAM不支持外键，InnoDB支持外键。
   - MyISAM是非聚簇索引，InnoDB是聚簇索引。MyISAM的索引节点上不保存数据文件，只保存数据的地址，InnoDB会保存数据文件。

### char和varchar的区别
​      char是定长，varchar是可变长。即当声明一个字段为char(10)类型时，如果存储的数据不满10个字符，但也会占用10个字符长度的空间，如果是varchar(10)，长度不满10个字符时，占用的空间数据实际长度+1个字节记录长度（如果超过255则用2个字节）；char的最大长度是255；char会截断尾部的空字符串，varchar不会；char适合保存较短的，长度较为固定的字符串，如MD5；varchar适合保存长度较为不固定的字符串，如地址，昵称等。

### 索引的理解
   索引类似我们平常看的书到目录，比如我要看mysql索引原理这部分的内容，没有目录的话我们只能一页一页的去翻找，而通过目录（索引）即能很快定位到在哪一页，极大的提升了我们查找数据的效率。
   // 索引分为聚簇索引和非聚簇索引（聚簇索引即数据按一定的顺序紧密的排列在一起，非聚簇相反）。

### 为什么使用B+树而不使用B树
​      主要是出于IO的考虑，B树的话除了叶子结点，非叶子结点也会存储数据，数据量一大致使树的高度也会增加不少，这样查找时需要加载更多的磁盘块，开销较大；反观B+树，只有在叶子结点存储数据，这样其他非叶子结点可以存储更多的关键字，且MySQL对B+树做了优化，使用双向循环链表。

### 什么情况下需要创建索引，哪些不需要
​       数据量较大，需要频繁where查询的字段，字段的数据应具备多样性，如果说一百万的数据，字段值只有几种的建立索引意义不大，高并发下，如果需要频繁用多个字段进行查询，可以考虑建立联合索引，需要数据库强约束唯一性的可以建立唯一索引，经常需要用做排序的字段。
​       数据量较少的，不常用做where查询的，字段数据种类少的，经常增删改的表。

### 哪些情况不走索引
   查询的数据占总数据量的一定百分比，好像是40%还是20%，且可能需要回表，会选择走全表；
索引字段使用函数不走索引；模糊搜索左边加上%的不走索引；使用组合索引的时候，如果第一个字段不在查询条件中也不会走索引（最左原则）;字符串不加单引号索引失效；使用or连接索引失效；使用is not null ，is null索引也会失效。

### 为什么推荐使用整型自增主键而不是选择UUID
​       UUID是字符串类型，会占用更多的空间；UUID本身无序，不适合用作范围查找，而自增ID的空间地址是连续的，范围查找速度更快；UUID新增删除的时候需要调整索引树的节点结构，而自增ID只需往后面追加，更节省开销。

### count(*) 和 count(1)和count(列名)区别
   count(*)和count(1)都可以将null统计进去，count(列名)会忽略值为null的数据。执行效率上，count(主键)效率最高，如果表没有主键，count(1)优于count(*)，如果表只有一个字段，count(*)最优。

### 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？
   ACID，原子性：事务不可分，事务执行的操作要么一起成功，要么一起失败；一致性：事务执行前后，数据表的完整性约束等没有收到破坏；隔离性：一个事务不能读取到另一个事务操作的数据；持久性：事务提交的数据可以进行持久化。
   事务的隔离级别分为：读未提交，读已提交，可重复读，串行化。

   - 读未提交：一个事务可以读取另一个事务未提交的内容，此隔离级别并发度最高，但是安全性也最低，会出现脏读，不可重复读及幻读。
   - 读已提交：一个事务只能读取另一个事务已提交的内容，可以阻止脏读，但是也会出现不可重复读及幻读。
   - 可重复读：一个事务中多次读取都能读取到相同的内容，可以阻止脏读和不可重复读，会出现幻读。
   - 串行化：一个数据有且只能同时有一个事务操作，并发度最低，安全性最高，可以有效避免以上所有问题，但是性能太差，一般不会使用。

  MySQL默认隔离级别是可重复读。

### 什么是幻读，脏读，不可重复读呢？
   脏读：一个事务读取到另一个事务未提交的内容就会出现脏读，比如：事务A先查询user表ID为1的的name字段的值为小明，事务B将此数据修改为小红，但此时并未提交，事务A再次查询发现变成小红，事务B因为某种原因回滚了数据，那这时事务A读到的就是脏数据。只要把事务隔离级别设为读已提交以上就能避免。
   不可重复读：一个事务读取前后的数据不一致，比如：事务A先是读取到name为小强的数据，此时事务B修改了该条数据为小花，并提交，而此时事务A再次读取发现数据变成了小花，前后读取的数据不一致。将事务隔离级别设为可重复读以上就可以避免。
   幻读：一个事务前后读取到的数据量发生变化，以为产生幻觉，比如：事务A读取分数为60以上的数据有10条，但此时事务B插入一条70分的数据，并提交，此时事务A再读取时发现变成了11条。事务隔离级别设为串行化可避免。

### MVCC实现原理
   MVCC即多版本并发控制，基本实现原理就是通过快照保存某一时间节点的数据，避免通过加锁的方式保证数据一致性，可并发性更高。在每条数据后面都会跟着一个新增时间和删除时间的版本号，这个时间指的并不是真的时间，是每个事务id+系统版本生成的标识，事务的id会根据开始的时间递增，这样在开启事务的时候，只会把新增时间小于当前事务id的数据或删除时间为无或删除时间的事务id大于当前事务id的数据读取进来，这样每次查询都能确保是事务开始之前的数据，不受其他事务的影响。不过缺点就是这样每条数据都需要增加新增时间和删除时间的版本号的成本，其次就是MVCC只在读已提交和可重复读的隔离级别下工作。


### 一致性读实现原理
​        首先声明关于一致性的讨论是在读已提交和可重复读的事物隔离级别情况下的，读未提交基本没有一致性可言，串行化直接加锁也没有讨论的必要。
​        所谓一致性读即快照读，在读取这部分数据的时候生成这部分数据的快照，多个事务读取的就是各自快照的数据，这样其中一个事务修改这部分数据的时候，其他事务再读取的时候数据依然不变，解决不可重复读的问题。主要的实现方式借助了undo log（回滚日志），记录下每个版本的数据逆操作，比如：insert了一行数据，undo log则记录delete这一行数据，反之delete则insert，update时，如果修改的列为非主键，则记录这次update的反操作，如果修改的列是主键，则删除这一行数据，再新增一行新数据。
​        在可重复读的隔离级别下，只有在select时才会创建快照，而读已提交的隔离级别下在事务开始的时候就会创建读快照。在查询的时候不仅会查询数据页，还会根据当前的事务ID查询undo log旧版本的数据（如果其他事务有修改数据），构建出一致性读的快照数据。

### ___事务的实现___
   我们都知道事务的特性就是ACID，而事务的隔离性就是通过锁实现的，而事务的原子性，一致性和持久性是靠事务日志实现的。事务日志包括redo log和undo log。redo log记录事务执行更新的数据，undo log是回滚日志，记录更新数据的逆操作。
   当进行update数据时，会往redo log记录这次更新的数据，同时也会写入undo log，当事务触发回滚的时候，会清除redo log这部分数据的内容，并执行undo log回滚该事务数据。InnoDB在将数据持久化到磁盘之前，其实会先写入InnoDB引擎缓存，再将缓存的数据记录到redo log，事务提交之前就会把缓存日志刷到磁盘，事务提交后，当redo log要被写满或者系统空闲的时候，就会将redo log映射的数据文件刷到磁盘进行持久化。

### 数据库的乐观锁和悲观锁
   乐观锁，就是数据库认为不会出现死锁，所以不会给数据加锁，但是会通过一个版本号的字段控制，如果版本不一致则需要先获取最新版本数据，此种方式并发性较好，缺点是需要维护版本号。
   悲观锁，就是数据库认为一定会出现死锁，所以在操作数据时会加上互斥锁，此种方式安全性较高，但是并发性较差，性能低。

### MySQL 中有哪几种锁
   MySQL的锁主要分为读锁和写锁，读锁就是在查询数据时加上的锁，读锁和读锁之间是不互斥的，一个事务加了读锁，其他事务也可以访问，但是会排斥写锁；写锁就是更新数据的时候加上的锁，写锁和读锁，写锁和写锁之间都是互斥的，数据加上写锁后，其他事务无法访问或更新该数据。
   如果从作用范围来讲，又可以分为全局锁，表锁，行锁。全局锁会将整个数据库实例锁住，进入只读状态，基本只有在数据备份的情况下使用；表锁会锁住整张表，锁的开销小，并发度小，可能会出现死锁问题；行锁，会锁住指定的数据行，锁的粒度小，并发度大，开销大，可能会出现死锁问题。InnoDB支持行锁，MyISAM仅支持到表锁。
   除此之外，InnoDB为了实现多粒度共存，还提供了两种表锁：意向共享锁，事务在给数据行加共享锁之前，需要先获取意向共享锁；意向排他锁，事务在给数据行加排他锁之前，需要先获取意向排他锁。

### 锁的模式
   InnoDB支持三种行锁的算法，记录锁，间隙锁和next-key-lock。
   记录锁，会锁住查询出的数据行，其他事务无法操作该数据行，一般通过主键查询出的数据就会加上记录锁，通过唯一索引操作的行也会加上记录锁，如：select * from user where id = 1 for update;
   间隙锁，主要是用来防止出现幻读，例如现在table中有id为1，5，10三条数据，此时查询id在（5，10）之间的数据，会查询出5，10两条数据。这时6，7，8，9都是空的，间隙锁就是作用于此的，如果有另外的事务想要插入id为6的数据是无法成功的，因为已经被间隙锁锁住了，可以有效避免出现幻读的情况。
   next-key-lock，其实就是记录锁和间隙锁的结合使用。主要也是为了防止幻读，会锁住查找数据的非唯一索引列左开右闭区间，对唯一索引的列是无效的，如果事务的隔离级别降为读已提交以下，next-ley-lock也是无效的。
   ps：InnoDB的行锁是基于索引实现的。
   
### select for update有什么含义，会锁表还是锁行还是其他
   for update只会在事务开启后使用，它会给查询出的结果集加上排他锁，会阻塞其他想要更新或删除这些数据的事务，排他锁包括表锁和行锁。如果是走了索引的数据会使用行锁，否则将会使用表锁。如：使用主键查询将会加上行锁的排他锁，如果使用没有索引的name值范围查找将会加上表锁。
   
### 死锁问题
   死锁的产生是由于多个进程/线程相互竞争对方持有的资源，导致进入永久阻塞状态，进程/线程都无法正常执行下去。MySQL中出现死锁，一般是事务之间以不同的顺序锁定资源，或者是多个事务争夺同一资源也会出现死锁。
   InnoDB中有自定的死锁检测机制，大致就是如果加的表锁，会将事务放到一个双向链表中，遍历等待的事务，如果遍历到同一个事务则证明成环，需要回滚代价较小的事务；如果是行锁会有hash桶来管理，找到hash桶中的所有行锁判断是否成环，否则则出现死锁。不过也不一定完全能检测出，所以一般都会设置锁的超时时间。
   MyISAM是直接获取一次SQL的所有锁，不会出现死锁。InnoDB中，可以在查询的时候就加上排他锁，不必等到更新时再加；如果事务中需要操作或修改多个表，其他事务也应以相同的顺序获取锁，在应用中最好事先约定好；增加事务隔离级别。

### 分表
   数据库分表分为水平拆分和垂直拆分。水平拆分即将一张表的数据分成多份，建立多个同样结构的表存储，就是一张表的数据分成多张存储，一般可以根据创建时间，或者区域行驶等拆分分类，适用于一张表的数据量过于庞大的情况，如用户表，订单表等。垂直拆分就是将表的字段拆出一部分，另起一张新表，数据增删改查的时候对这两张表进行操作，一般适用于表的字段数过多，业务复杂的情况，或者数据统计等。
   
   
