### Go的调度模型
   go的并发主要是依靠goroutine，也就是协程实现的。协程就是用户态线程，比起内核态线程，用户态线程具有：系统内核无感知，切换上下文的代价更低，可以由语言框架调度，更小的栈空间，允许创建大量实例。
   go的并发模型实现就是GMP，所谓G就是goroutine，M表示调度器，P表示逻辑处理器。在正常情况下，我们会开很多个goroutine，但是cpu核心数就只有那几个，所以会把这些goroutine放在一个全局的队列中，在需要调度某个goroutine的时候，会先把goroutine放到P的本地队列中，然后M会取出P队列中的第一个goroutine并调度执行。如果P的本地队列空了就会去全局队列取goroutine，如果全局队列也空了，那就去偷别的P的本地队列。如果运行过程中G阻塞了，那么这个G会被放到一个等待队列中，而M则尝试获取下一个可执行的G，如果P中没有可执行的G，则M会进入sleep状态。而进入等待队列的G，有可能被其他G1唤醒，唤醒后进入可执行状态，进入G1所在的队列中等待被调度。
   
### Go的并发模型
   Go常用的并发模型有：通过channel并发控制，无缓存的channel是同步形式的，需要读写达到同一时间节点上，如果先执行到读channel，那么线程会进入阻塞等待，等待往channel写入数据，如果先执行到写，同样也会阻塞等待读channel，所以只需要在主线程结束前执行读无缓存channel，即可等待其他协程执行到位。
   还有一种就是使用同步等待组包（sync.WaitGroup），在主线程声明添加需要等待的对应协程数，在需要等待的地方调用wait方法，则主线程执行到那就会进入等待，每个协程在执行完之后调用done方法，发送信号给到主线程，表示执行完成了，主线程即将要等待的协程数减一，知道减为0，就正常执行下去。
   还有一种就是Go1.7以后引进的强大的Context功能，实现并发控制。