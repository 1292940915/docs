### Go的调度模型
   go的并发主要是依靠goroutine，也就是协程实现的。协程就是用户态线程，比起内核态线程，用户态线程具有：系统内核无感知，切换上下文的代价更低，可以由语言框架调度，更小的栈空间，允许创建大量实例。
   go的并发模型实现就是GMP，所谓G就是goroutine，M表示调度器，P表示逻辑处理器。在正常情况下，我们会开很多个goroutine，但是cpu核心数就只有那几个，所以会把这些goroutine放在一个全局的队列中，在需要调度某个goroutine的时候，会先把goroutine放到P的本地队列中，然后M会取出P队列中的第一个goroutine并调度执行。如果P的本地队列空了就会去全局队列取goroutine，如果全局队列也空了，那就去偷别的P的本地队列。如果运行过程中G阻塞了，那么这个G会被放到一个等待队列中，而M则尝试获取下一个可执行的G，如果P中没有可执行的G，则M会进入sleep状态。而进入等待队列的G，有可能被其他G1唤醒，唤醒后进入可执行状态，进入G1所在的队列中等待被调度。

### Go的并发模型
   Go常用的并发模型有：通过channel并发控制，无缓存的channel是同步形式的，需要读写达到同一时间节点上，如果先执行到读channel，那么线程会进入阻塞等待，等待往channel写入数据，如果先执行到写，同样也会阻塞等待读channel，所以只需要在主线程结束前执行读无缓存channel，即可等待其他协程执行到位。
   还有一种就是使用同步等待组包（sync.WaitGroup），在主线程声明添加需要等待的对应协程数，在需要等待的地方调用wait方法，则主线程执行到那就会进入等待，每个协程在执行完之后调用done方法，发送信号给到主线程，表示执行完成了，主线程即将要等待的协程数减一，知道减为0，就正常执行下去。
   还有一种就是Go1.7以后引进的强大的Context功能，实现并发控制。

### map的实现方式
   go的map是通过拉链法来解决hash冲突的，它的访问，获取，删除等操作都是在编译时期转换成运行时期的函数或者方法，hash的每个桶中的存储键都会对应hash的前8位，这样方便快速定位到目标数据。
   hash的每个桶最多只能存储8个键值对，当超过8个后，就会将其存储到溢出桶中，随着键值对的数量增加，溢出桶中的键值对和装载因子（已存储的键值对/桶的数量）也会随着上升，到达一定的阈值就会触发扩容，扩容会将桶的数量翻倍，再分配的时候也是调用写时的增量同步，不会产生巨大的抖动拖垮性能。map会在两种情况下触发扩容：装载因子超过6.5；溢出桶的数量太多。不过扩容过程并不是原子性的，所以还需要判断状态是否在扩容，避免产生二次扩容。扩容时，会将以前的桶标记为oldBuckets，将新桶标为Buckets，后面的数据都会存放到新桶中。溢出桶也用如此的设计。
   
### Sync.Pool特点及使用场景
   对象池，就是预先初始化某一类的对象，然后提供给其他协程直接从池子里取，用完之后就放回去，如果取的时候取完了，其他还没还回来则无法再获取，不过也可以再次初始化一批对象进去。他的主要使用场景就是，对一些比较复杂特别大的对象，可以对其反复的回收利用，达到节省内存空间的目的，可以避免频繁的创建和销毁对象。
   对象池本身就是线程安全的，可以让多个goroutine并发调用使用；对象池在使用后不可复制。
   
### Context的使用场景
   上下文的信息传递；子goroutine切换控制；超时的方法调用；可以取消的方法调用。
   
### GO的数组和切片
   数组在申请内存时需要先清空对应内存数据；数组是固定大小的，无法存放超过容量的数据；数组是值类型，在传递参数时会拷贝其对应的值副本，对传递副本的修改不会影响原数组。切片长度是不固定的，可以动态扩容；切片比数组多了一个容量参数；切片是指针类型；切片底层就是数组。
   go中的数组是值类型的，不同于C/C++中的数组结构，每次赋值都会拷贝出一个新的数组，数组中的数据也会被拷贝一份，如果数组包含非常大的数据量，那这样多拷贝出几个数组对系统的开销的庞大的，无疑费时又占空间。对于切片，并不能说它是动态数组或者数组指针，它本身就是一种只读对象，是对数组指针的一种封装。对数组的一部分连续片段的引用，可以说是引用类型，它的引用可以是一整个数组，也可以是从起始索引到终止索引到引用，终止索引后并不包含在切片内，就是一个数组的动态窗口。
   切片扩容的时候，如果容量小于1024，则扩容的时候容量翻倍，如果容量超过1024，那扩容的倍数就变成1.25，增长因子也就变小了，