### OSI体系结构，TCP/IP体系结构，五层体系结构
   OSI体系模型主要分为七层，分别是：应用层，表示层，会话层，传输层，网络层，链路层，物理层。
   应用层，为各应用程序直接提供服务，实现在系统中多个应用进程通信，支撑各种业务开展。如：文件传输，发送邮件等。
   表示层，接收应用层传递的数据，并对数据进行处理，如加/解密，编码转换等。
   会话层，通过传输层的服务建立和维持会话。
   传输层，涉及两个节点的数据传输服务，为上层服务提供可靠的数据传输。传输层服务一般要经历传输连接，释放和数据传输三个阶段才算是一个比较完整的传输服务。
   网络层，提供一个端经过若干节点到另一个端的传输服务。
   链路层，提供一条链路的数据传输服务。
   物理层，为整个传输过程提供可靠的物理介质，如一些媒体硬件设备等。
   TCP/IP体系结构只有四层：应用层，传输层（TCP，UDP），网络层（IP），通用链路层。其中应用层包括OSI模型中的应用层，表示层和会话层。通用链路层包含了链路层和物理层。

### IP协议
   互联网协议，是TCP/IP协议簇的核心，构成整个互联网体系的重要基础，在运输层提供数据的分发，同时也能进行数据组装供运输层传输使用。通过IP协议连接多个端到端之间，形成网络体系，提高网络的扩展性。

### ARP协议
   地址解析协议，当我们需要给某个主机发送数据的时候，就需要知道那台主机的物理地址，获取方式就是通过广播发送消息给局域网下的其他主机，如果是有主机认出找的是自己，则会回应并返回物理地址给到发送者，其他不是的则不理会。收到物理地址之后，会将该主机的IP和对应的物理地址存储到缓存区，之后如果还要找的话就直接去缓存区查询就可以了。

### TCP协议和UDP协议
   TCP协议是传输控制协议，面向连接为我们提供可靠的传输服务，将数据转换成字节流进行传输，可以通过重传和拥塞控制的机制保证数据传输的可靠性，应用广泛，登录，文件传输等。
   UDP协议是用户数据报协议，面向无连接的并不提供可靠性传输服务的协议，并不会保证传输的数据会成功到达终端，也没有如重传和拥塞控制之类的机制，特点是传输的速度快，传输的报文也比TCP报文小，应用场景如，广播。

### HTTP是什么？
   是可以让端对端之间进行通信交流，传递诸如文本，媒体，图片等的超文本无状态协议。他是一种双向协议，可以客户端到服务端，也可以服务端到客户端，服务端到服务端，同时也可以进行中转，像客户端A到服务端到客户端B。通过这类约定俗称的协议才会使我们的网络环境更见规范化安全化。
   HTTP的特性是：简单易扩展，报文是以header+body的方式传递，header也是以key-value方式填充，并且它的method，header之类的可以容开发人员自行补充，灵活度高；明文传输，它传递数据是非加密的，数据直接暴露出来，容易受到第三方劫持，非常不安全；无状态，HTTP不会保存用户的状态信息，比如用户登录进来，关掉了网页，再打开的时候又需要登录了，解决的话就出了cookie。
   
### HTTP1.1特性
   在该版本中，弥补了1.0只能使用短链接的方式交互，可以使用长连接，一次连接进行多次请求，减少频繁的请求连接流程；使用管道传输，就是客户端发送一次请求后，不必等待响应可以再次发送其他请求，这些请求传递到服务端后可以被顺序执行，但是如果前面的请求执行慢的话，后面的也只能等待了，因此性能一般。

### ___HTTP中的字段有哪些？___
   Host，请求目标的域名；Header，分为请求头部和响应头部信息，主要是对当前请求/响应声明其一些属性，约束编码/解码等规范；Method，请求方法，包括GET，POST，PUT，PATCH，DELETE等方法，适用于不同场景；Body，主体信息，如果是请求的话，里面可以包含POST请求的参数数据

### GET与POST的区别
   GET通常用来查询获取数据，请求参数一般拼接在域名后面，传递的参数数据有限，同时GET请求会被浏览器主动缓存，具有安全性（不会破坏服务器资源），幂等性（多次请求返回的数据一致）。
   POST通常用来提交表单，新增数据，请求参数会放在body中，可以传递较大量的数据，请求不会被浏览器缓存，不具有安全性，幂等性。
   
### 三次握手和四次挥手
   三次握手就是在客户端和服务端进行TCP连接所经历的一个交互过程，握手成功之后才是正事建立连接并传递交流数据。开始时服务端处于CLOSED状态，然后进入LISTEND状态开始接收客户端的连接请求，客户端正式发起连接请求syn，服务端接收到客户端的连接请求后，将服务端的syn+1，并返回服务端的syn+ack给客户端，客户端接收到服务端的确认序列后，又再返回客户端的确认序列ack给到服务端，第三次握手可以传输数据，这就是三次握手的过程了。
   四次挥手就是客户端和服务端终止连接的过程所经历的过程，断开连接的请求可以是任意一方发起。首先发起方接收完数据想要断开连接了，就发起断开连接的请求fin给到接收方，接收方接收到断开请求后，就会回应一个确认序列号ack给到发起方，表示自己知道了，但是这时接收方可能还有数据没有接收完，所以在等到接收方的数据接收完成后，接收方会发出断开连接fin序列给到发起方，发起方接收到接收方的fin序列后，就回应确认序列ack给到接收方，此时发起方进入time_wait
状态，时间一般是2MSL（报文生存的最大时间），防止接收方没及时接收到发起方的ack又重发fin，而发起方没接收到，这就是四次挥手。
   为什么一定要三次握手呢，两次不行吗？假设如果只有两次握手的话，客户端发出连接请求syn，但此时网络卡顿，第一次发出的syn服务端没有接收到，于是再次发出一个syn2，此时syn2被服务端接收并响应ack了，建立连接。但此时第一次发出的syn到达了服务端，服务端此时懵了，明明已经建立连接为什么还要一个，服务端此时会直接rst断开连接。还有就是保存对方的序列号，请求应答序列号是保证双方基于此次连接交流的重要依靠。
   
### 什么是SYN攻击？
   服务端在建立连接时，会有两个队列存放连接请求，一个是存放发起连接请求的未连接队列（SYN队列），当经过三次握手后就会将SYN队列中的连接放入已连接队列（Accept队列），在进行TCP三次握手的时候，第一次握手客户端发起连接请求SYN时，如果服务端没有及时回应ack，则可能网路通道不是很顺畅，客户端会重新发起请求。但是被有心人在短时间内伪造不同的IP地址，疯狂发送SYN请求给到服务端，服务端的未连接队列可能就因此被占满，导致那些正常的连接无法连上服务端。
   如何防止攻击呢？一种就是增大SYN队列的大小，可以接受更多的连接请求，当然这种办法是治标不治本的。还有一种就是，当SYN队列满了的时候就存放到cookie，然后正常返回SYN+ACK，如果有回应的话就把cookie的连接请求放入Accept队列，否则就丢弃。
   
### HTTPS与HTTP
   我们都知道HTTP比较致命的一个缺点就是明文传输，数据传递过程中极不安全，还可能出现劫持问题，HTTPS弥补了HTTP这一致命弱点。HTTPS协议连接时除了要经历TCP三次握手之外，还需要SSL/TLS连接。首先需要向CA机构申请合法的数字签名及一对公私密钥，私钥服务端自己保留，公钥在客户端发起请求时和证书一起发送给客户端，客户端收到证书后会先验证其的合法性，比如是否到期，域名是否对应之类的，如果不通过则发出警告，通过的话就会用公钥加密一段随机生成的key，用于后续的对称加/解密，然后发送给服务端，服务端接收到之后就会用私钥解密得到明文key，后续服务端就会用该key进行对称加密数据发送给客户端，客户端接收到后可以用key对称解密得到明文内容。