### OSI体系结构，TCP/IP体系结构，五层体系结构
   OSI体系模型主要分为七层，分别是：应用层，表示层，会话层，传输层，网络层，链路层，物理层。
   应用层，为各应用程序直接提供服务，实现在系统中多个应用进程通信，支撑各种业务开展。如：文件传输，发送邮件等。
   表示层，接收应用层传递的数据，并对数据进行处理，如加/解密，编码转换等。
   会话层，通过传输层的服务建立和维持会话。
   传输层，涉及两个节点的数据传输服务，为上层服务提供可靠的数据传输。传输层服务一般要经历传输连接，释放和数据传输三个阶段才算是一个比较完整的传输服务。
   网络层，提供一个端经过若干节点到另一个端的传输服务。
   链路层，提供一条链路的数据传输服务。
   物理层，为整个传输过程提供可靠的物理介质，如一些媒体硬件设备等。
   TCP/IP体系结构只有四层：应用层，传输层（TCP，UDP），网络层（IP），通用链路层。其中应用层包括OSI模型中的应用层，表示层和会话层。通用链路层包含了链路层和物理层。

### IP协议
   互联网协议，是TCP/IP协议簇的核心，构成整个互联网体系的重要基础，在运输层提供数据的分发，同时也能进行数据组装供运输层传输使用。通过IP协议连接多个端到端之间，形成网络体系，提高网络的扩展性。

### ARP协议
   地址解析协议，当我们需要给某个主机发送数据的时候，就需要知道那台主机的物理地址，获取方式就是通过广播发送消息给局域网下的其他主机，如果是有主机认出找的是自己，则会回应并返回物理地址给到发送者，其他不是的则不理会。收到物理地址之后，会将该主机的IP和对应的物理地址存储到缓存区，之后如果还要找的话就直接去缓存区查询就可以了。

### TCP协议和UDP协议
   TCP协议是传输控制协议，面向连接为我们提供可靠的传输服务，将数据转换成字节流进行传输，可以通过重传和拥塞控制的机制保证数据传输的可靠性，应用广泛，登录，文件传输等。
   UDP协议是用户数据报协议，面向无连接的并不提供可靠性传输服务的协议，并不会保证传输的数据会成功到达终端，也没有如重传和拥塞控制之类的机制，特点是传输的速度快，传输的报文也比TCP报文小，应用场景如，广播。

### HTTP是什么？
   是可以让端对端之间进行通信交流，传递诸如文本，媒体，图片等的超文本无状态协议。他是一种双向协议，可以客户端到服务端，也可以服务端到客户端，服务端到服务端，同时也可以进行中转，像客户端A到服务端到客户端B。通过这类约定俗称的协议才会使我们的网络环境更见规范化安全化。
   HTTP的特性是：简单易扩展，报文是以header+body的方式传递，header也是以key-value方式填充，并且它的method，header之类的可以容开发人员自行补充，灵活度高；明文传输，它传递数据是非加密的，数据直接暴露出来，容易受到第三方劫持，非常不安全；无状态，HTTP不会保存用户的状态信息，比如用户登录进来，关掉了网页，再打开的时候又需要登录了，解决的话就出了cookie。

### HTTP1.1特性
   在该版本中，弥补了1.0只能使用短链接的方式交互，可以使用长连接，一次连接进行多次请求，减少频繁的请求连接流程；使用管道传输，就是客户端发送一次请求后，不必等待响应可以再次发送其他请求，这些请求传递到服务端后可以被顺序执行，但是如果前面的请求执行慢的话，后面的也只能等待了，因此性能一般。

### ___HTTP中的字段有哪些？___
   Host，请求目标的域名；Header，分为请求头部和响应头部信息，主要是对当前请求/响应声明其一些属性，约束编码/解码等规范；Method，请求方法，包括GET，POST，PUT，PATCH，DELETE等方法，适用于不同场景；Body，主体信息，如果是请求的话，里面可以包含POST请求的参数数据

### GET与POST的区别
   GET通常用来查询获取数据，请求参数一般拼接在域名后面，传递的参数数据有限，同时GET请求会被浏览器主动缓存，具有安全性（不会破坏服务器资源），幂等性（多次请求返回的数据一致）。
   POST通常用来提交表单，新增数据，请求参数会放在body中，可以传递较大量的数据，请求不会被浏览器缓存，不具有安全性，幂等性。

### 三次握手和四次挥手
   三次握手就是在客户端和服务端进行TCP连接所经历的一个交互过程，握手成功之后才是正事建立连接并传递交流数据。开始时服务端处于CLOSED状态，然后进入LISTEND状态开始接收客户端的连接请求，客户端正式发起连接请求syn，服务端接收到客户端的连接请求后，将服务端的syn+1，并返回服务端的syn+ack给客户端，客户端接收到服务端的确认序列后，又再返回客户端的确认序列ack给到服务端，第三次握手可以传输数据，这就是三次握手的过程了。
   四次挥手就是客户端和服务端终止连接的过程所经历的过程，断开连接的请求可以是任意一方发起。首先发起方接收完数据想要断开连接了，就发起断开连接的请求fin给到接收方，接收方接收到断开请求后，就会回应一个确认序列号ack给到发起方，表示自己知道了，但是这时接收方可能还有数据没有接收完，所以在等到接收方的数据接收完成后，接收方会发出断开连接fin序列给到发起方，发起方接收到接收方的fin序列后，就回应确认序列ack给到接收方，此时发起方进入time_wait
状态，时间一般是2MSL（报文生存的最大时间），防止接收方没及时接收到发起方的ack又重发fin，而发起方没接收到，这就是四次挥手。
   为什么一定要三次握手呢，两次不行吗？假设如果只有两次握手的话，客户端发出连接请求syn，但此时网络卡顿，第一次发出的syn服务端没有接收到，于是再次发出一个syn2，此时syn2被服务端接收并响应ack了，建立连接。但此时第一次发出的syn到达了服务端，服务端此时懵了，明明已经建立连接为什么还要一个，服务端此时会直接rst断开连接。还有就是保存对方的序列号，请求应答序列号是保证双方基于此次连接交流的重要依靠。

### 怎么解决2MSL产生的问题？
   在四次挥手后，主动断开方在发出ACK后会进入time_wait状态，等待2MSL时间，防止被断开方因为网络卡顿之类的问题没收到ACK进行重试发送FIN，如果这时断开方已经CLOSED，被断开方的FIN就没法接受到。
   但是如果网络高峰期连接请求很多的话，一个连接断开就要等待2MSL时间，这样服务端明明有很多空闲的连接了但是客户端还是需要等待一段时间才能连上，造成网络堵塞。一种方法就是快速回收，即不等待2MSL时间立刻回收，但是这样就可能出现上面的问题，因此不建议；还有一种方法就是重用断开的连接，发起连接的时候重用处于time_wait超过1s时间的连接，但是显然如果断开方是服务端，那根本就没有解决服务端的问题，因此尽量让客户端主动断开连接。

### 什么是SYN攻击？
   服务端在建立连接时，会有两个队列存放连接请求，一个是存放发起连接请求的未连接队列（SYN队列），当经过三次握手后就会将SYN队列中的连接放入已连接队列（Accept队列），在进行TCP三次握手的时候，第一次握手客户端发起连接请求SYN时，如果服务端没有及时回应ack，则可能网路通道不是很顺畅，客户端会重新发起请求。但是被有心人在短时间内伪造不同的IP地址，疯狂发送SYN请求给到服务端，服务端的未连接队列可能就因此被占满，导致那些正常的连接无法连上服务端。
   如何防止攻击呢？一种就是增大SYN队列的大小，可以接受更多的连接请求，当然这种办法是治标不治本的。还有一种就是，当SYN队列满了的时候就存放到cookie，然后正常返回SYN+ACK，如果有回应的话就把cookie的连接请求放入Accept队列，否则就丢弃。


### 超时重传，快速重传，SACK，D-SACK
   TCP的重传机制是保证可靠性传输的有效手段，重传机制主要有超时重传，快速重传，SACK和D-SACK。
   超时重传就是当发送TCP数据包后，没有在一定时间内收到接收方ACK，就会重新发送。超时重传一般会在发送的数据包丢失和确认的应答包丢失情况触发。但是这个时间的选取也很关键，如果时间长了，过了比较久才重试，显然对我们的整个请求的时间加大不少，但是如果短了，过了没多久就重试，如果那时网络只是有一点延迟，那就会频繁引起重试。因此时间上一般会选取略大于一次请求过去到接受回来的时间，但是网络环境比较复杂，一次的来回时间不能代表大多数，因此就需要采样取平均值，为了数据更具有真实性和普遍性使用的是加权平均值计算（取倒数平均值）。如果超时重传后，又出现超时，那么重传的时间会加倍，因为那样就证明网络环境比较差，不适合频繁请求。
   快速重传，发送方在发送一个数据包后，多次收到接收方返回的那个数据包的应答ACK，说明那个数据包出现问题，于是触发重传。比如：客户端发送了（1，2，3，4，5）5个数据包给到服务端，此时客户端先是收到1的应答ACK，然后收到2的应答ACK，之后又收到2的应答ACK，以此重复多次后，说明数据包2传输出现问题，于是进行重发数据包2。虽然解决了超时的时间问题，但是缺不知道这后面的几个数据包2的ACK是谁发的，可能是3，可能是4，因此就不知道需要重发2，还是重发（2，3，4，5）。
   SACK（选择性重传），实现上就是在TCP头部选项内容增加一个缓存地图，把接收到的数据放到缓冲地图，这样接受确认ACK的时候就知道丢失了哪部分的数据了，可以选择那些丢失的数据进行重传。
   D-SACK，主要是通过SACK来告诉发送方哪些数据被重复发送了。比如说，发送方发送了（1，10）的数据包，接收方接收到了，此时返回（1，10）的确认包，但此时网络出现延迟之类的问题，确认包没有及时到达发送方，发送方又发送了一次（1，10）的数据包，接收方收到后发现是重复的，于是返回D-SACK给发送方。还有一种场景就是，发送方发送（1，10）的数据包，因为网络延迟问题，数据包没法及时到达接收方，此时接收方触发快速重传，发送方再次发送（1，10）的数据包，而此时第一次发送的数据包刚好到达接收方，而第二次发送的数据包也到达了，于是触发接收方发送D-SACK。
   
### 滑动窗口
   在网络环境传递数据交流过程中，我们知道发送过去的数据是要收到确认的，如果都是这样你一句我一句的方式交流，那这样数据交流的效率太慢了。于是引入窗口，接收方可以声明窗口大小，表示还可以接受多少数据包，发送方根据接收方的窗口大小连续发送多少数据而不需要得到应答，提高网络吞吐量。窗口实际上就是发送方开辟了一个缓存区，将要发送的数据包放入缓存区，发送的数据包正常得到应答后就将那部分数据包清除。因为数据包接受情况是根据接收方而定的，所以窗口大小也是由接收方而确定，发送方不能发送超过窗口大小的数据包，不然接收方会处理不来。
   对于发送方的滑动窗口，可以分为四部分：已发送并且已收到回应的数据范围，已发送但并未收到回应的数据，未发送但是处于可发送区间范围，未发送处于不可发送的数据范围（从左至右）。滑动窗口的主要范围是在已发送但未回应的数据和可发送的数据范围和。如果此时已发送但未回应的前面几个数据包收到回应了，则窗口向右滑动，可发送范围增加，已发送未回应范围减小；如果可发送的范围数据发送出去的几个数据包，那么此时已发送但未回应的范围变大，可发送的范围减小；如果此时接收方不可接受数据了，那么可发送的范围变为0，窗口就包含了已发送但未收到回应范围数据，发送方此时也不会发送，会等待接收方回应已发送的数据。发送方有三个指针表示滑动窗口，一个是表示窗口大小的指针；还有一个指向已发送但未接受范围的第一个数据包，期望下次能收到从那个数据包开始的回应，并根据此开始滑动；还有一个是指向可发送范围的第一个数据包，表示下次发送从此数据包开始，以此滑动已发送范围。
   接收方的滑动窗口主要分为三部分：已接受已回应的数据范围，未接受但可接受的数据范围，不可接受的范围（从左至右）。如果此时回应了发送方的部分数据包，则窗口会向右滑动。接收方滑动窗口有两个指针表示，一个是窗口大小，另一个是指向不可接受范围的第一个数据包，表示下次期望收到从那个数据包开始的数据。
   发送方和接受方的窗口大小理论上应该是保持一致的，但是因为网络环境的复杂性，这是很难把控的，所以他们之间的大小是约等于的关系。
   
### 流量控制
   正常情况下发送方需要根据接受方接受数据的实际情况控制发送数据的速率，这就是流量控制。
   
### 拥塞控制
   

### HTTPS与HTTP
   我们都知道HTTP比较致命的一个缺点就是明文传输，数据传递过程中极不安全，还可能出现劫持问题，HTTPS弥补了HTTP这一致命弱点。HTTPS协议连接时除了要经历TCP三次握手之外，还需要SSL/TLS连接。首先需要向CA机构申请合法的数字签名及一对公私密钥，私钥服务端自己保留，公钥在客户端发起请求时和证书一起发送给客户端，客户端收到证书后会先验证其的合法性，比如是否到期，域名是否对应之类的，如果不通过则发出警告，通过的话就会用公钥加密一段随机生成的key，用于后续的对称加/解密，然后发送给服务端，服务端接收到之后就会用私钥解密得到明文key，后续服务端就会用该key进行对称加密数据发送给客户端，客户端接收到后可以用key对称解密得到明文内容。